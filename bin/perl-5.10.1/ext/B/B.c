/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of B.xs. Do not edit this file, edit B.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "B.xs"
/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static const char* const svclassnames[] = {
    "B::NULL",
#if PERL_VERSION >= 9
    "B::BIND",
#endif
    "B::IV",
    "B::NV",
#if PERL_VERSION <= 10
    "B::RV",
#endif
    "B::PV",
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
#if PERL_VERSION <= 8
    "B::BM",
#endif
#if PERL_VERSION >= 11
    "B::REGEXP",
#endif
#if PERL_VERSION >= 9
    "B::GV",
#endif
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
#if PERL_VERSION <= 8
    "B::GV",
#endif
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP	/* 11 */
} opclass;

static const char* const opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP"	
};

static const size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)	
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
    SV *	x_specialsv_list[7];
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)

static opclass
cc_opclass(pTHX_ const OP *o)
{
    if (!o)
	return OPc_NULL;

    if (o->op_type == 0)
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

    if (o->op_type == OP_AELEMFAST) {
	if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP, and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
		? OPc_SVOP : OPc_PVOP;

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 PL_op_name[o->op_type]);
    return OPc_BASEOP;
}

static char *
cc_opclassname(pTHX_ const OP *o)
{
    return (char *)opclassnames[cc_opclass(aTHX_ o)];
}

static SV *
make_sv_object(pTHX_ SV *arg, SV *sv)
{
    const char *type = 0;
    IV iv;
    dMY_CXT;
    
    for (iv = 0; iv < sizeof(specialsv_list)/sizeof(SV*); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

#if PERL_VERSION >= 9
static SV *
make_temp_object(pTHX_ SV *arg, SV *temp)
{
    SV *target;
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ SV *arg, STRLEN *warnings)
{
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ arg,
				newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ SV *arg, COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_temp_object(aTHX_ arg, newSVsv(value));
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ arg, NULL);
    }
}
#endif

static SV *
make_mg_object(pTHX_ SV *arg, MAGIC *mg)
{
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr = newSVpvn("", 0);

    if (!SvOK(sv))
	sv_setpvn(sstr, "0", 1);
    else if (perlstyle && SvUTF8(sv)) {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	sv_setpvn(sstr,"\"",1);
	while (*s)
	{
	    if (*s == '"')
		sv_catpvn(sstr, "\\\"", 2);
	    else if (*s == '$')
		sv_catpvn(sstr, "\\$", 2);
	    else if (*s == '@')
		sv_catpvn(sstr, "\\@", 2);
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpvn(sstr, "\\\\", 2);
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
	sv_catpv(sstr, "\"");
	return sstr;
    }
    else
    {
	/* XXX Optimise? */
	STRLEN len;
	const char *s = SvPV(sv, len);
	sv_catpv(sstr, "\"");
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpv(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpv(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
                sprintf(escbuff, "\\%03o", '?');
                sv_catpv(sstr, escbuff);
            }
	    else if (perlstyle && *s == '$')
		sv_catpv(sstr, "\\$");
	    else if (perlstyle && *s == '@')
		sv_catpv(sstr, "\\@");
#ifdef EBCDIC
	    else if (isPRINT(*s))
#else
	    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpv(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpv(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpv(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpv(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpv(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpv(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpv(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
		const unsigned char c = (unsigned char) *s;
		sprintf(escbuff, "\\%03o", c);
		sv_catpv(sstr, escbuff);
	    }
	    /* XXX Add line breaks if string is long */
	}
	sv_catpv(sstr, "\"");
    }
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvn("'", 1);
    const char *s = SvPV_nolen(sv);

    if (*s == '\'')
	sv_catpvn(sstr, "\\'", 2);
    else if (*s == '\\')
	sv_catpvn(sstr, "\\\\", 2);
#ifdef EBCDIC
    else if (isPRINT(*s))
#else
    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
	sv_catpvn(sstr, s, 1);
    else if (*s == '\n')
	sv_catpvn(sstr, "\\n", 2);
    else if (*s == '\r')
	sv_catpvn(sstr, "\\r", 2);
    else if (*s == '\t')
	sv_catpvn(sstr, "\\t", 2);
    else if (*s == '\a')
	sv_catpvn(sstr, "\\a", 2);
    else if (*s == '\b')
	sv_catpvn(sstr, "\\b", 2);
    else if (*s == '\f')
	sv_catpvn(sstr, "\\f", 2);
    else if (*s == '\v')
	sv_catpvn(sstr, "\\v", 2);
    else
    {
	/* no trigraph support */
	char escbuff[5]; /* to fit backslash, 3 octals + trailing \0 */
	/* Don't want promotion of a signed -1 char in sprintf args */
	unsigned char c = (unsigned char) *s;
	sprintf(escbuff, "\\%03o", c);
	sv_catpv(sstr, escbuff);
    }
    sv_catpvn(sstr, "'", 1);
    return sstr;
}

#if PERL_VERSION >= 9
#  define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot
#else
#  define PMOP_pmreplstart(o)	o->op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplroot
#  define PMOP_pmpermflags(o)	o->op_pmpermflags
#  define PMOP_pmdynflags(o)      o->op_pmdynflags
#endif

static void
walkoptree(pTHX_ SV *opsv, const char *method)
{
    dSP;
    OP *o, *kid;
    dMY_CXT;

    if (!SvROK(opsv))
	croak("opsv is not a reference");
    opsv = sv_mortalcopy(opsv);
    o = INT2PTR(OP*,SvIV((SV*)SvRV(opsv)));
    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(opsv);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(opsv);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = kid->op_sibling) {
	    /* Use the same opsv. Rely on methods not to mess it up. */
	    sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	    walkoptree(aTHX_ opsv, method);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
           && (kid = PMOP_pmreplroot(cPMOPo)))
    {
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ kid)), PTR2IV(kid));
	walkoptree(aTHX_ opsv, method);
    }
}

static SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	SV *opsv;
#if PERL_VERSION >= 9
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
#else
	if (o->op_seq == 0)
	    break;
	o->op_seq = 0;
#endif
	opsv = sv_newmortal();
	sv_setiv(newSVrv(opsv, cc_opclassname(aTHX_ (OP*)o)), PTR2IV(o));
	XPUSHs(opsv);
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ PMOP_pmreplstart(cPMOPo), SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = cLISTOPo->op_first->op_sibling;   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
#if PERL_VERSION >= 11
typedef SV	*B__REGEXP;
#endif
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;
typedef HE      *B__HE;
#if PERL_VERSION >= 9
typedef struct refcounted_he	*B__RHE;
#endif

#line 602 "B.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 645 "B.c"
#define B_main_cv()	PL_main_cv
#define B_init_av()	PL_initav
#define B_inc_gv()	PL_incgv
#define B_check_av()	PL_checkav_save
#if PERL_VERSION > 8
#  define B_unitcheck_av()	PL_unitcheckav_save
#else
#  define B_unitcheck_av()	NULL
#endif
#define B_begin_av()	PL_beginav_save
#define B_end_av()	PL_endav
#define B_main_root()	PL_main_root
#define B_main_start()	PL_main_start
#define B_amagic_generation()	PL_amagic_generation
#define B_sub_generation()	PL_sub_generation
#define B_defstash()	PL_defstash
#define B_curstash()	PL_curstash
#define B_dowarn()	PL_dowarn
#define B_comppadlist()	(PL_main_cv ? CvPADLIST(PL_main_cv) : CvPADLIST(PL_compcv))
#define B_sv_undef()	&PL_sv_undef
#define B_sv_yes()	&PL_sv_yes
#define B_sv_no()	&PL_sv_no
#define B_formfeed()	PL_formfeed
#ifdef USE_ITHREADS
#define B_regex_padav()	PL_regex_padav
#endif

XS(XS_B_init_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_init_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_init_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_check_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_check_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_check_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAA 1


XS(XS_B_unitcheck_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_unitcheck_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_unitcheck_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B_begin_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_begin_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_begin_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_end_av); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_end_av)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_end_av();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_inc_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_inc_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__GV	RETVAL;

	RETVAL = B_inc_gv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#ifdef USE_ITHREADS
#define XSubPPtmpAAAB 1


XS(XS_B_regex_padav); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_regex_padav)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_regex_padav();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B_main_cv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_cv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__CV	RETVAL;

	RETVAL = B_main_cv();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_root)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__OP	RETVAL;

	RETVAL = B_main_root();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B_main_start); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_main_start)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__OP	RETVAL;

	RETVAL = B_main_start();
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B_amagic_generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_amagic_generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;

	RETVAL = B_amagic_generation();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_sub_generation); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sub_generation)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;

	RETVAL = B_sub_generation();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_comppadlist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_comppadlist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__AV	RETVAL;

	RETVAL = B_comppadlist();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_undef); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_undef)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_undef();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_yes); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_yes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_yes();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_sv_no); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_sv_no)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_sv_no();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_curstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_curstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__HV	RETVAL;

	RETVAL = B_curstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_defstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_defstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__HV	RETVAL;

	RETVAL = B_defstash();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_dowarn); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_dowarn)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	U8	RETVAL;
	dXSTARG;

	RETVAL = B_dowarn();
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_formfeed); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_formfeed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	B__SV	RETVAL;

	RETVAL = B_formfeed();
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_warnhook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_warnhook)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 712 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_warnhook);
#line 1146 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_diehook); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_diehook)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 717 "B.xs"
	ST(0) = make_sv_object(aTHX_ sv_newmortal(), PL_diehook);
#line 1165 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_walkoptree); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "opsv, method");
    {
	SV *	opsv = ST(0);
	const char *	method = (const char *)SvPV_nolen(ST(1));
#line 726 "B.xs"
	walkoptree(aTHX_ opsv, method);
#line 1186 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_walkoptree_debug); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_walkoptree_debug)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 731 "B.xs"
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
#line 1209 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define address(sv) PTR2IV(sv)

XS(XS_B_address); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_address)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	IV	RETVAL;
	dXSTARG;

	RETVAL = address(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_svref_2object); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_svref_2object)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	B__SV	RETVAL;
#line 748 "B.xs"
	if (!SvROK(sv))
	    croak("argument is not a reference");
	RETVAL = (SV*)SvRV(sv);
#line 1256 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B_opnumber); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_opnumber)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0));
#line 758 "B.xs"
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
#line 1295 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_ppname); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_ppname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "opnum");
    {
	int	opnum = (int)SvIV(ST(0));
#line 779 "B.xs"
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo) {
	    sv_setpvn(ST(0), "pp_", 3);
	    sv_catpv(ST(0), PL_op_name[opnum]);
	}
#line 1319 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
#line 789 "B.xs"
	STRLEN len;
	U32 hash = 0;
	char hexhash[19]; /* must fit "0xffffffffffffffff" plus trailing \0 */
	const char *s = SvPV(sv, len);
	PERL_HASH(hash, s, len);
	sprintf(hexhash, "0x%"UVxf, (UV)hash);
	ST(0) = sv_2mortal(newSVpv(hexhash, 0));
#line 1345 "B.c"
    }
    XSRETURN(1);
}

#define cast_I32(foo) (I32)foo

XS(XS_B_cast_I32); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cast_I32)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	IV	i = (IV)SvIV(ST(0));
	IV	RETVAL;
	dXSTARG;

	RETVAL = cast_I32(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B_minus_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_minus_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 805 "B.xs"
	PL_minus_c = TRUE;
#line 1387 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_save_BEGINs); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_save_BEGINs)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 810 "B.xs"
	PL_savebegin = TRUE;
#line 1406 "B.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_B_cstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 816 "B.xs"
	RETVAL = cstring(aTHX_ sv, 0);
#line 1427 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_perlstring); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_perlstring)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 824 "B.xs"
	RETVAL = cstring(aTHX_ sv, 1);
#line 1450 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_cchar); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_cchar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 832 "B.xs"
	RETVAL = cchar(aTHX_ sv);
#line 1473 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B_threadsv_names); /* prototype to pass -Wmissing-prototypes */
XS(XS_B_threadsv_names)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 839 "B.xs"
#if PERL_VERSION <= 8
# ifdef USE_5005THREADS
	int i;
	const STRLEN len = strlen(PL_threadsv_names);

	EXTEND(sp, len);
	for (i = 0; i < len; i++)
	    PUSHs(sv_2mortal(newSVpvn(&PL_threadsv_names[i], 1)));
# endif
#endif
#line 1505 "B.c"
	PUTBACK;
	return;
    }
}

#define OP_next(o)	o->op_next
#define OP_sibling(o)	o->op_sibling
#define OP_desc(o)	(char *)PL_op_desc[o->op_type]
#define OP_targ(o)	o->op_targ
#define OP_type(o)	o->op_type
#if PERL_VERSION >= 9
#  define OP_opt(o)	o->op_opt
#else
#  define OP_seq(o)	o->op_seq
#endif
#define OP_flags(o)	o->op_flags
#define OP_private(o)	o->op_private
#define OP_spare(o)	o->op_spare

XS(XS_B__OP_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	size_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 870 "B.xs"
	RETVAL = opsizes[cc_opclass(aTHX_ o)];
#line 1548 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_next(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__OP_sibling); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_sibling)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_sibling(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__OP_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 886 "B.xs"
	RETVAL = (char *)PL_op_name[o->op_type];
#line 1638 "B.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__OP_ppaddr); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_ppaddr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
#line 895 "B.xs"
	int i;
	SV *sv = sv_newmortal();
#line 1660 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 898 "B.xs"
	sv_setpvn(sv, "PL_ppaddr[OP_", 13);
	sv_catpv(sv, PL_op_name[o->op_type]);
	for (i=13; (STRLEN)i < SvCUR(sv); ++i)
	    SvPVX(sv)[i] = toUPPER(SvPVX(sv)[i]);
	sv_catpv(sv, "]");
	ST(0) = sv;
#line 1675 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__OP_desc); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_desc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_desc(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__OP_targ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_targ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_targ(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_type(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAC 1


XS(XS_B__OP_opt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_opt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_opt(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1


XS(XS_B__OP_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__OP_flags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_flags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_flags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__OP_private); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_private)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_private(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAE 1


XS(XS_B__OP_spare); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_spare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = OP_spare(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__OP_oplist); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__OP_oplist)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference");
#line 951 "B.xs"
	SP = oplist(aTHX_ o, SP);
#line 1947 "B.c"
	PUTBACK;
	return;
    }
}

#define UNOP_first(o)	o->op_first

XS(XS_B__UNOP_first); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__UNOP_first)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__UNOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__UNOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = UNOP_first(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define BINOP_last(o)	o->op_last

XS(XS_B__BINOP_last); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BINOP_last)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__BINOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__BINOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = BINOP_last(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define LOGOP_other(o)	o->op_other

XS(XS_B__LOGOP_other); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOGOP_other)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOGOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOGOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOGOP_other(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LISTOP_children); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LISTOP_children)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LISTOP	o;
	OP *	kid;
	int	i;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LISTOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 985 "B.xs"
	i = 0;
	for (kid = o->op_first; kid; kid = kid->op_sibling)
	    i++;
	RETVAL = i;
#line 2075 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define PMOP_pmnext(o)		o->op_pmnext
#define PMOP_pmregexp(o)	PM_GETRE(o)
#ifdef USE_ITHREADS
#define PMOP_pmoffset(o)	o->op_pmoffset
#define PMOP_pmstashpv(o)	PmopSTASHPV(o);
#else
#define PMOP_pmstash(o)		PmopSTASH(o);
#endif
#define PMOP_pmflags(o)		o->op_pmflags
#if PERL_VERSION <= 8
#define XSubPPtmpAAAF 1


XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	OP *	root;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1011 "B.xs"
	ST(0) = sv_newmortal();
	root = o->op_pmreplroot;
	/* OP_PUSHRE stores an SV* instead of an OP* in op_pmreplroot */
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), INT2PTR(PADOFFSET,root) );
#  else
	    sv_setiv(newSVrv(ST(0), root ?
			     svclassnames[SvTYPE((SV*)root)] : "B::SV"),
		     PTR2IV(root));
#  endif
	}
	else {
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)), PTR2IV(root));
	}
#line 2130 "B.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAG 1


XS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplroot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1033 "B.xs"
	ST(0) = sv_newmortal();
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), o->op_pmreplrootu.op_pmtargetoff);
#  else
	    GV *const target = o->op_pmreplrootu.op_pmtargetgv;
	    sv_setiv(newSVrv(ST(0), target ?
			     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
		     PTR2IV(target));
#  endif
	}
	else {
	    OP *const root = o->op_pmreplrootu.op_pmreplroot; 
	    sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ root)),
		     PTR2IV(root));
	}
#line 2175 "B.c"
    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_pmreplstart); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmreplstart)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmreplstart(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAH 1


XS(XS_B__PMOP_pmnext); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmnext)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmnext(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#endif
#ifdef USE_ITHREADS
#define XSubPPtmpAAAI 1


XS(XS_B__PMOP_pmoffset); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmoffset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmoffset(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PMOP_pmstashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstashpv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAJ 1


XS(XS_B__PMOP_pmstash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmstash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmstash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_pmflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAK 1


XS(XS_B__PMOP_pmpermflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmpermflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmpermflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PMOP_pmdynflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_pmdynflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PMOP_pmdynflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__PMOP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1103 "B.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setpvn(ST(0), RX_PRECOMP(rx), RX_PRELEN(rx));
#line 2458 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAL 1


XS(XS_B__PMOP_reflags); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PMOP_reflags)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	REGEXP *	rx;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1115 "B.xs"
	ST(0) = sv_newmortal();
	rx = PM_GETRE(o);
	if (rx)
	    sv_setuv(ST(0), RX_EXTFLAGS(rx));
#line 2492 "B.c"
    }
    XSRETURN(1);
}

#endif
#define SVOP_sv(o)     cSVOPo->op_sv
#define SVOP_gv(o)     ((GV*)cSVOPo->op_sv)

XS(XS_B__SVOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__SVOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__SVOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SVOP_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__SVOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__SVOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = SVOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#define PADOP_padix(o)	o->op_padix
#define PADOP_sv(o)	(o->op_padix ? PAD_SVl(o->op_padix) : Nullsv)
#define PADOP_gv(o)	((o->op_padix \
			  && SvTYPE(PAD_SVl(o->op_padix)) == SVt_PVGV) \
			 ? (GV*)PAD_SVl(o->op_padix) : (GV *)NULL)

XS(XS_B__PADOP_padix); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_padix)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PADOP	o;
	PADOFFSET	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_padix(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PADOP_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PADOP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_sv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PADOP_gv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PADOP_gv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PADOP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = PADOP_gv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PVOP_pv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVOP_pv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PVOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PVOP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1161 "B.xs"
	/*
	 * OP_TRANS uses op_pv to point to a table of 256 or >=258 shorts
	 * whereas other PVOPs point to a null terminated string.
	 */
	if (o->op_type == OP_TRANS &&
		(o->op_private & OPpTRANS_COMPLEMENT) &&
		!(o->op_private & OPpTRANS_DELETE))
	{
	    const short* const tbl = (short*)o->op_pv;
	    const short entries = 257 + tbl[256];
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, entries * sizeof(short)));
	}
	else if (o->op_type == OP_TRANS) {
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 256 * sizeof(short)));
	}
	else
	    ST(0) = sv_2mortal(newSVpv(o->op_pv, 0));
#line 2696 "B.c"
    }
    XSRETURN(1);
}

#define LOOP_redoop(o)	o->op_redoop
#define LOOP_nextop(o)	o->op_nextop
#define LOOP_lastop(o)	o->op_lastop

XS(XS_B__LOOP_redoop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_redoop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_redoop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LOOP_nextop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_nextop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_nextop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__LOOP_lastop); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__LOOP_lastop)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LOOP	o;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LOOP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = LOOP_lastop(o);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#define COP_label(o)	CopLABEL(o)
#define COP_stashpv(o)	CopSTASHPV(o)
#define COP_stash(o)	CopSTASH(o)
#define COP_file(o)	CopFILE(o)
#define COP_filegv(o)	CopFILEGV(o)
#define COP_cop_seq(o)	o->cop_seq
#define COP_arybase(o)	CopARYBASE_get(o)
#define COP_line(o)	CopLINE(o)
#define COP_hints(o)	CopHINTS_get(o)
#if PERL_VERSION < 9
#  define COP_warnings(o)  o->cop_warnings
#  define COP_io(o)	o->cop_io
#endif
#if PERL_VERSION >= 11
#define XSubPPtmpAAAM 1


XS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	const char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAN 1


XS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#endif

XS(XS_B__COP_stashpv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stashpv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__COP_stash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_stash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_stash(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_file(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__COP_filegv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_filegv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_filegv(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_cop_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_cop_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_cop_seq(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__COP_arybase); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_arybase)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_arybase(o);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__COP_line); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_line)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_line(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAO 1


XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1263 "B.xs"
	ST(0) = make_warnings_object(aTHX_ sv_newmortal(), o->cop_warnings);
	XSRETURN(1);
#line 3107 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__COP_io); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_io)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1270 "B.xs"
	ST(0) = make_cop_io_object(aTHX_ sv_newmortal(), o);
	XSRETURN(1);
#line 3138 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__COP_hints_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_hints_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__RHE	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");
#line 1277 "B.xs"
	RETVAL = o->cop_hints_hash;
#line 3167 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::RHE"), PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAP 1


XS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_warnings)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_warnings(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__COP_io); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_io)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_io(o);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__COP_hints); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__COP_hints)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference");

	RETVAL = COP_hints(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_SvTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_SvTYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvTYPE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define object_2svref(sv)	sv
#define SVREF SV *

XS(XS_B__SV_object_2svref); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_object_2svref)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	SVREF	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = object_2svref(sv);
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__SV_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_REFCNT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvREFCNT(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvFLAGS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_POK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_POK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPOK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_ROK); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_ROK)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvROK(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__SV_MAGICAL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__SV_MAGICAL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvMAGICAL(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_IV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIV(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_IVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_IVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvIVX(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_UVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_UVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	UV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvUVX(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#define needs64bits(sv) ((I32)SvIVX(sv) != SvIVX(sv))

XS(XS_B__IV_needs64bits); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_needs64bits)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = needs64bits(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IV_packiv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_packiv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1359 "B.xs"
	if (sizeof(IV) == 8) {
	    U32 wp[2];
	    const IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = sv_2mortal(newSVpvn((char *)wp, 8));
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = sv_2mortal(newSVpvn((char *)&w, 4));
	}
#line 3633 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 11
#define XSubPPtmpAAAQ 1


XS(XS_B__IV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1388 "B.xs"
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
#line 3669 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__NV_NV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNV(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_NVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_NVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvNVX(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_COP_SEQ_RANGE_LOW); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_COP_SEQ_RANGE_LOW)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = COP_SEQ_RANGE_LOW(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_COP_SEQ_RANGE_HIGH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_COP_SEQ_RANGE_HIGH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = COP_SEQ_RANGE_HIGH(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_PARENT_PAD_INDEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_PARENT_PAD_INDEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = PARENT_PAD_INDEX(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__NV_PARENT_FAKELEX_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__NV_PARENT_FAKELEX_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = PARENT_FAKELEX_FLAGS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 11
#define XSubPPtmpAAAR 1


XS(XS_B__RV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__RV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__RV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__RV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvRV(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#endif

XS(XS_B__PV_PVX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvPVX(sv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__PV_RV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_RV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1445 "B.xs"
        if( SvROK(sv) ) {
            RETVAL = SvRV(sv);
        }
        else {
            croak( "argument is not SvROK" );
        }
#line 3945 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1458 "B.xs"
        ST(0) = sv_newmortal();
        if( SvPOK(sv) ) {
	    /* FIXME - we need a better way for B to identify PVs that are
	       in the pads as variable names.  */
	    if((SvLEN(sv) && SvCUR(sv) >= SvLEN(sv))) {
		/* It claims to be longer than the space allocated for it -
		   presuambly it's a variable name in the pad  */
		sv_setpv(ST(0), SvPV_nolen_const(sv));
	    } else {
		sv_setpvn(ST(0), SvPVX_const(sv), SvCUR(sv));
	    }
            SvFLAGS(ST(0)) |= SvUTF8(sv);
        }
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
            sv_setpvn(ST(0), NULL, 0);
        }
#line 3993 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PV_PVBM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_PVBM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1484 "B.xs"
        ST(0) = sv_newmortal();
	sv_setpvn(ST(0), SvPVX_const(sv),
	    SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0));
#line 4022 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PV_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_LEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PV_CUR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PV_CUR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvCUR(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVMG_MAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_MAGIC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PVMG	sv;
	MAGIC *	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1504 "B.xs"
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ sv_newmortal(), mg));
#line 4111 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__PVMG_SvSTASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVMG_SvSTASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVMG	sv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = SvSTASH(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 11
#define XSubPPtmpAAAS 1


XS(XS_B__REGEXP_REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__REGEXP_REGEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__REGEXP	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__REGEXP,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1521 "B.xs"
	RETVAL = PTR2IV(((struct xregexp *)SvANY(sv))->xrx_regexp);
#line 4175 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__REGEXP_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__REGEXP_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__REGEXP	sv;
	REGEXP*	rx;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__REGEXP,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1530 "B.xs"
	rx = ((struct xregexp *)SvANY(sv))->xrx_regexp;
	/* FIXME - UTF-8? And the equivalent precomp methods? */
	RETVAL = newSVpvn( RX_PRECOMP(rx), RX_PRELEN(rx) );
#line 4207 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#define MgMOREMAGIC(mg) mg->mg_moremagic
#define MgPRIVATE(mg) mg->mg_private
#define MgTYPE(mg) mg->mg_type
#define MgFLAGS(mg) mg->mg_flags
#define MgOBJ(mg) mg->mg_obj
#define MgLENGTH(mg) mg->mg_len
#define MgREGEX(mg) PTR2IV(mg->mg_obj)

XS(XS_B__MAGIC_MOREMAGIC); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_MOREMAGIC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	B__MAGIC	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1552 "B.xs"
	if( MgMOREMAGIC(mg) ) {
	    RETVAL = MgMOREMAGIC(mg);
	}
	else {
	    XSRETURN_UNDEF;
	}
#line 4250 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::MAGIC"), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_PRIVATE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PRIVATE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgPRIVATE(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_TYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgTYPE(mg);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_FLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_FLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgFLAGS(mg);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_OBJ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_OBJ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgOBJ(mg);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_REGEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_REGEX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1581 "B.xs"
        if(mg->mg_type == PERL_MAGIC_qr) {
            RETVAL = MgREGEX(mg);
        }
        else {
            croak( "REGEX is only meaningful on r-magic" );
        }
#line 4405 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_precomp); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_precomp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1594 "B.xs"
        if (mg->mg_type == PERL_MAGIC_qr) {
            REGEXP* rx = (REGEXP*)mg->mg_obj;
            RETVAL = Nullsv;
            if( rx )
                RETVAL = newSVpvn( RX_PRECOMP(rx), RX_PRELEN(rx) );
        }
        else {
            croak( "precomp is only meaningful on r-magic" );
        }
#line 4442 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_LENGTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_LENGTH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");

	RETVAL = MgLENGTH(mg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__MAGIC_PTR); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__MAGIC_PTR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    {
	B__MAGIC	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference");
#line 1614 "B.xs"
	ST(0) = sv_newmortal();
 	if (mg->mg_ptr){
		if (mg->mg_len >= 0){
	    		sv_setpvn(ST(0), mg->mg_ptr, mg->mg_len);
		} else if (mg->mg_len == HEf_SVKEY) {
			ST(0) = make_sv_object(aTHX_
				    sv_newmortal(), (SV*)mg->mg_ptr);
		}
	}
#line 4508 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARGOFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGOFF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGOFF(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARGLEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARGLEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARGLEN(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTYPE(sv);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__PVLV_TARG); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__PVLV_TARG)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PVLV	sv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVLV,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = LvTARG(sv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__BM_USEFUL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_USEFUL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmUSEFUL(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_PREVIOUS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_PREVIOUS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmPREVIOUS(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_RARE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_RARE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");

	RETVAL = BmRARE(sv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__BM_TABLE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__BM_TABLE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	STRLEN	len;
	char *	str;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference");
#line 1662 "B.xs"
	str = SvPV(sv, len);
	/* Boyer-Moore table is just after string and its safety-margin \0 */
	ST(0) = sv_2mortal(newSVpvn(str + len + PERL_FBM_TABLE_OFFSET, 256));
#line 4744 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__GV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1672 "B.xs"
	ST(0) = sv_2mortal(newSVpvn(GvNAME(gv), GvNAMELEN(gv)));
#line 4771 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__GV_is_empty); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_is_empty)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1678 "B.xs"
        RETVAL = GvGP(gv) == Null(GP*);
#line 4799 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__GV_isGV_with_GP); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_isGV_with_GP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1686 "B.xs"
#if PERL_VERSION >= 9
	RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
#else
	RETVAL = TRUE; /* In 5.8 and earlier they all are.  */
#endif
#line 4833 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__GV_GP); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvGP(gv);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_B__GV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_STASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSTASH(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_SV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_SV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvSV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_IO); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_IO)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__IO	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvIO(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_FORM); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FORM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__FM	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");
#line 1714 "B.xs"
	RETVAL = (SV*)GvFORM(gv);
#line 4985 "B.c"
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_AV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_AV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvAV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_HV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_HV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvHV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_EGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_EGV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_CV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_CVGEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_CVGEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvCVGEN(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_LINE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_LINE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvLINE(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILE(gv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__GV_FILEGV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_FILEGV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFILEGV(gv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__GV_GvREFCNT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvREFCNT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvREFCNT(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__GV_GvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__GV_GvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference");

	RETVAL = GvFLAGS(gv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_PAGE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_PAGE_LEN); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_PAGE_LEN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoPAGE_LEN(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_LINES_LEFT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_LINES_LEFT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoLINES_LEFT(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__IO_TOP_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_TOP_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_TOP_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTOP_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__IO_FMT_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_FMT_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_FMT_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFMT_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__IO_BOTTOM_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_NAME(io);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__IO_BOTTOM_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_BOTTOM_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoBOTTOM_GV(io);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION <= 8
#define XSubPPtmpAAAT 1


XS(XS_B__IO_SUBPROCESS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_SUBPROCESS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	short	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoSUBPROCESS(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__IO_IsSTD); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IsSTD)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "io, name");
    {
	B__IO	io;
	const char*	name = (const char *)SvPV_nolen(ST(1));
#line 1815 "B.xs"
	PerlIO* handle = 0;
#line 5639 "B.c"
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");
#line 1817 "B.xs"
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
#line 5662 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_B__IO_IoTYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoTYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	char	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoTYPE(io);
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_B__IO_IoFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__IO_IoFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference");

	RETVAL = IoFLAGS(io);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__AV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_FILL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFILL(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__AV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_MAX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvMAX(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define AvOFF(av) ((XPVAV*)SvANY(av))->xof_off
#define XSubPPtmpAAAU 1


XS(XS_B__AV_OFF); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_OFF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvOFF(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__AV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1868 "B.xs"
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ sv_newmortal(), svp[i]));
	}
#line 5848 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__AV_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_ARRAYelt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "av, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;
	int	idx = (int)SvIV(ST(1));

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");
#line 1880 "B.xs"
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ sv_newmortal(), NULL));
#line 5882 "B.c"
	PUTBACK;
	return;
    }
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAV 1


XS(XS_B__AV_AvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__AV_AvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference");

	RETVAL = AvFLAGS(av);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS(XS_B__FM_LINES); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__FM_LINES)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "form");
    {
	B__FM	form;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    form = INT2PTR(B__FM,tmp);
	}
	else
	    croak("form is not a reference");

	RETVAL = FmLINES(form);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_CONST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CONST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvCONST(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_STASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_STASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__HV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvSTASH(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_START); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_START)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1915 "B.xs"
	RETVAL = CvISXSUB(cv) ? NULL : CvSTART(cv);
#line 6033 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__CV_ROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_ROOT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__OP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1923 "B.xs"
	RETVAL = CvISXSUB(cv) ? NULL : CvROOT(cv);
#line 6064 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}


XS(XS_B__CV_GV); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_GV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__GV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvGV(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_FILE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_FILE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFILE(cv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_B__CV_DEPTH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_DEPTH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	long	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvDEPTH(cv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_PADLIST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvPADLIST(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_OUTSIDE); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__CV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__CV_OUTSIDE_SEQ); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_OUTSIDE_SEQ)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvOUTSIDE_SEQ(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_XSUB); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUB)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1955 "B.xs"
	ST(0) = sv_2mortal(newSViv(CvISXSUB(cv) ? PTR2IV(CvXSUB(cv)) : 0));
#line 6274 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__CV_XSUBANY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_XSUBANY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");
#line 1962 "B.xs"
	ST(0) = CvCONST(cv) ?
	    make_sv_object(aTHX_ sv_newmortal(),(SV *)CvXSUBANY(cv).any_ptr) :
	    sv_2mortal(newSViv(CvISXSUB(cv) ? CvXSUBANY(cv).any_iv : 0));
#line 6303 "B.c"
    }
    XSRETURN(1);
}


XS(XS_B__CV_CvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_CvFLAGS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U16	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = CvFLAGS(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__CV_const_sv); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__CV_const_sv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference");

	RETVAL = cv_const_sv(cv);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__HV_FILL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_FILL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvFILL(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_MAX); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_MAX)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvMAX(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_KEYS); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_KEYS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvKEYS(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_RITER); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_RITER)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvRITER(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HV_NAME); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_NAME)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvNAME(hv);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAW 1


XS(XS_B__HV_PMROOT); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_PMROOT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");

	RETVAL = HvPMROOT(hv);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), cc_opclassname(aTHX_ (OP*)RETVAL)), PTR2IV(RETVAL));

    }
    XSRETURN(1);
}

#endif

XS(XS_B__HV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HV_ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HV	hv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference");
#line 2013 "B.xs"
	if (HvKEYS(hv) > 0) {
	    SV *sv;
	    char *key;
	    I32 len;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvKEYS(hv) * 2);
	    while ((sv = hv_iternextsv(hv, &key, &len))) {
		mPUSHp(key, len);
		PUSHs(make_sv_object(aTHX_ sv_newmortal(), sv));
	    }
	}
#line 6581 "B.c"
	PUTBACK;
	return;
    }
}


XS(XS_B__HE_VAL); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_VAL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeVAL(he);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}


XS(XS_B__HE_HASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_HASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeHASH(he);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_B__HE_SVKEY_force); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__HE_SVKEY_force)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	B__SV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference");

	RETVAL = HeSVKEY_force(he);
	ST(0) = sv_newmortal();
	make_sv_object(aTHX_ (ST(0)), (SV*)(RETVAL));


    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAX 1


XS(XS_B__RHE_HASH); /* prototype to pass -Wmissing-prototypes */
XS(XS_B__RHE_HASH)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	B__RHE	h;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(B__RHE,tmp);
	}
	else
	    croak("h is not a reference");
#line 2047 "B.xs"
	RETVAL = newRV( (SV*)Perl_refcounted_he_chain_2hv(aTHX_ h) );
#line 6704 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS(boot_B); /* prototype to pass -Wmissing-prototypes */
XS(boot_B)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("B::init_av", XS_B_init_av, file);
        newXS("B::check_av", XS_B_check_av, file);
#if XSubPPtmpAAAA
        newXS("B::unitcheck_av", XS_B_unitcheck_av, file);
#endif
        newXS("B::begin_av", XS_B_begin_av, file);
        newXS("B::end_av", XS_B_end_av, file);
        newXS("B::inc_gv", XS_B_inc_gv, file);
#if XSubPPtmpAAAB
        newXS("B::regex_padav", XS_B_regex_padav, file);
#endif
        newXS("B::main_cv", XS_B_main_cv, file);
        newXS("B::main_root", XS_B_main_root, file);
        newXS("B::main_start", XS_B_main_start, file);
        newXS("B::amagic_generation", XS_B_amagic_generation, file);
        newXS("B::sub_generation", XS_B_sub_generation, file);
        newXS("B::comppadlist", XS_B_comppadlist, file);
        newXS("B::sv_undef", XS_B_sv_undef, file);
        newXS("B::sv_yes", XS_B_sv_yes, file);
        newXS("B::sv_no", XS_B_sv_no, file);
        newXS("B::curstash", XS_B_curstash, file);
        newXS("B::defstash", XS_B_defstash, file);
        newXS("B::dowarn", XS_B_dowarn, file);
        newXS("B::formfeed", XS_B_formfeed, file);
        newXS("B::warnhook", XS_B_warnhook, file);
        newXS("B::diehook", XS_B_diehook, file);
        newXS("B::walkoptree", XS_B_walkoptree, file);
        newXS("B::walkoptree_debug", XS_B_walkoptree_debug, file);
        newXS("B::address", XS_B_address, file);
        newXS("B::svref_2object", XS_B_svref_2object, file);
        newXS("B::opnumber", XS_B_opnumber, file);
        newXS("B::ppname", XS_B_ppname, file);
        newXS("B::hash", XS_B_hash, file);
        newXS("B::cast_I32", XS_B_cast_I32, file);
        newXS("B::minus_c", XS_B_minus_c, file);
        newXS("B::save_BEGINs", XS_B_save_BEGINs, file);
        newXS("B::cstring", XS_B_cstring, file);
        newXS("B::perlstring", XS_B_perlstring, file);
        newXS("B::cchar", XS_B_cchar, file);
        newXS("B::threadsv_names", XS_B_threadsv_names, file);
        newXS("B::OP::size", XS_B__OP_size, file);
        newXS("B::OP::next", XS_B__OP_next, file);
        newXS("B::OP::sibling", XS_B__OP_sibling, file);
        newXS("B::OP::name", XS_B__OP_name, file);
        newXS("B::OP::ppaddr", XS_B__OP_ppaddr, file);
        newXS("B::OP::desc", XS_B__OP_desc, file);
        newXS("B::OP::targ", XS_B__OP_targ, file);
        newXS("B::OP::type", XS_B__OP_type, file);
#if XSubPPtmpAAAC
        newXS("B::OP::opt", XS_B__OP_opt, file);
#endif
#if XSubPPtmpAAAD
        newXS("B::OP::seq", XS_B__OP_seq, file);
#endif
        newXS("B::OP::flags", XS_B__OP_flags, file);
        newXS("B::OP::private", XS_B__OP_private, file);
#if XSubPPtmpAAAE
        newXS("B::OP::spare", XS_B__OP_spare, file);
#endif
        newXS("B::OP::oplist", XS_B__OP_oplist, file);
        newXS("B::UNOP::first", XS_B__UNOP_first, file);
        newXS("B::BINOP::last", XS_B__BINOP_last, file);
        newXS("B::LOGOP::other", XS_B__LOGOP_other, file);
        newXS("B::LISTOP::children", XS_B__LISTOP_children, file);
#if XSubPPtmpAAAF
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
#if XSubPPtmpAAAG
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
        newXS("B::PMOP::pmreplstart", XS_B__PMOP_pmreplstart, file);
#if XSubPPtmpAAAH
        newXS("B::PMOP::pmnext", XS_B__PMOP_pmnext, file);
#endif
#if XSubPPtmpAAAI
        newXS("B::PMOP::pmoffset", XS_B__PMOP_pmoffset, file);
        newXS("B::PMOP::pmstashpv", XS_B__PMOP_pmstashpv, file);
#endif
#if XSubPPtmpAAAJ
        newXS("B::PMOP::pmstash", XS_B__PMOP_pmstash, file);
#endif
        newXS("B::PMOP::pmflags", XS_B__PMOP_pmflags, file);
#if XSubPPtmpAAAK
        newXS("B::PMOP::pmpermflags", XS_B__PMOP_pmpermflags, file);
        newXS("B::PMOP::pmdynflags", XS_B__PMOP_pmdynflags, file);
#endif
        newXS("B::PMOP::precomp", XS_B__PMOP_precomp, file);
#if XSubPPtmpAAAL
        newXS("B::PMOP::reflags", XS_B__PMOP_reflags, file);
#endif
        newXS("B::SVOP::sv", XS_B__SVOP_sv, file);
        newXS("B::SVOP::gv", XS_B__SVOP_gv, file);
        newXS("B::PADOP::padix", XS_B__PADOP_padix, file);
        newXS("B::PADOP::sv", XS_B__PADOP_sv, file);
        newXS("B::PADOP::gv", XS_B__PADOP_gv, file);
        newXS("B::PVOP::pv", XS_B__PVOP_pv, file);
        newXS("B::LOOP::redoop", XS_B__LOOP_redoop, file);
        newXS("B::LOOP::nextop", XS_B__LOOP_nextop, file);
        newXS("B::LOOP::lastop", XS_B__LOOP_lastop, file);
#if XSubPPtmpAAAM
        newXS("B::COP::label", XS_B__COP_label, file);
#endif
#if XSubPPtmpAAAN
        newXS("B::COP::label", XS_B__COP_label, file);
#endif
        newXS("B::COP::stashpv", XS_B__COP_stashpv, file);
        newXS("B::COP::stash", XS_B__COP_stash, file);
        newXS("B::COP::file", XS_B__COP_file, file);
        newXS("B::COP::filegv", XS_B__COP_filegv, file);
        newXS("B::COP::cop_seq", XS_B__COP_cop_seq, file);
        newXS("B::COP::arybase", XS_B__COP_arybase, file);
        newXS("B::COP::line", XS_B__COP_line, file);
#if XSubPPtmpAAAO
        newXS("B::COP::warnings", XS_B__COP_warnings, file);
        newXS("B::COP::io", XS_B__COP_io, file);
        newXS("B::COP::hints_hash", XS_B__COP_hints_hash, file);
#endif
#if XSubPPtmpAAAP
        newXS("B::COP::warnings", XS_B__COP_warnings, file);
        newXS("B::COP::io", XS_B__COP_io, file);
#endif
        newXS("B::COP::hints", XS_B__COP_hints, file);
        newXS("B::SV::SvTYPE", XS_B__SV_SvTYPE, file);
        newXS("B::SV::object_2svref", XS_B__SV_object_2svref, file);
        newXS("B::SV::REFCNT", XS_B__SV_REFCNT, file);
        newXS("B::SV::FLAGS", XS_B__SV_FLAGS, file);
        newXS("B::SV::POK", XS_B__SV_POK, file);
        newXS("B::SV::ROK", XS_B__SV_ROK, file);
        newXS("B::SV::MAGICAL", XS_B__SV_MAGICAL, file);
        newXS("B::IV::IV", XS_B__IV_IV, file);
        newXS("B::IV::IVX", XS_B__IV_IVX, file);
        newXS("B::IV::UVX", XS_B__IV_UVX, file);
        newXS("B::IV::needs64bits", XS_B__IV_needs64bits, file);
        newXS("B::IV::packiv", XS_B__IV_packiv, file);
#if XSubPPtmpAAAQ
        newXS("B::IV::RV", XS_B__IV_RV, file);
#endif
        newXS("B::NV::NV", XS_B__NV_NV, file);
        newXS("B::NV::NVX", XS_B__NV_NVX, file);
        newXS("B::NV::COP_SEQ_RANGE_LOW", XS_B__NV_COP_SEQ_RANGE_LOW, file);
        newXS("B::NV::COP_SEQ_RANGE_HIGH", XS_B__NV_COP_SEQ_RANGE_HIGH, file);
        newXS("B::NV::PARENT_PAD_INDEX", XS_B__NV_PARENT_PAD_INDEX, file);
        newXS("B::NV::PARENT_FAKELEX_FLAGS", XS_B__NV_PARENT_FAKELEX_FLAGS, file);
#if XSubPPtmpAAAR
        newXS("B::RV::RV", XS_B__RV_RV, file);
#endif
        newXS("B::PV::PVX", XS_B__PV_PVX, file);
        newXS("B::PV::RV", XS_B__PV_RV, file);
        newXS("B::PV::PV", XS_B__PV_PV, file);
        newXS("B::PV::PVBM", XS_B__PV_PVBM, file);
        newXS("B::PV::LEN", XS_B__PV_LEN, file);
        newXS("B::PV::CUR", XS_B__PV_CUR, file);
        newXS("B::PVMG::MAGIC", XS_B__PVMG_MAGIC, file);
        newXS("B::PVMG::SvSTASH", XS_B__PVMG_SvSTASH, file);
#if XSubPPtmpAAAS
        newXS("B::REGEXP::REGEX", XS_B__REGEXP_REGEX, file);
        newXS("B::REGEXP::precomp", XS_B__REGEXP_precomp, file);
#endif
        newXS("B::MAGIC::MOREMAGIC", XS_B__MAGIC_MOREMAGIC, file);
        newXS("B::MAGIC::PRIVATE", XS_B__MAGIC_PRIVATE, file);
        newXS("B::MAGIC::TYPE", XS_B__MAGIC_TYPE, file);
        newXS("B::MAGIC::FLAGS", XS_B__MAGIC_FLAGS, file);
        newXS("B::MAGIC::OBJ", XS_B__MAGIC_OBJ, file);
        newXS("B::MAGIC::REGEX", XS_B__MAGIC_REGEX, file);
        newXS("B::MAGIC::precomp", XS_B__MAGIC_precomp, file);
        newXS("B::MAGIC::LENGTH", XS_B__MAGIC_LENGTH, file);
        newXS("B::MAGIC::PTR", XS_B__MAGIC_PTR, file);
        newXS("B::PVLV::TARGOFF", XS_B__PVLV_TARGOFF, file);
        newXS("B::PVLV::TARGLEN", XS_B__PVLV_TARGLEN, file);
        newXS("B::PVLV::TYPE", XS_B__PVLV_TYPE, file);
        newXS("B::PVLV::TARG", XS_B__PVLV_TARG, file);
        newXS("B::BM::USEFUL", XS_B__BM_USEFUL, file);
        newXS("B::BM::PREVIOUS", XS_B__BM_PREVIOUS, file);
        newXS("B::BM::RARE", XS_B__BM_RARE, file);
        newXS("B::BM::TABLE", XS_B__BM_TABLE, file);
        newXS("B::GV::NAME", XS_B__GV_NAME, file);
        newXS("B::GV::is_empty", XS_B__GV_is_empty, file);
        newXS("B::GV::isGV_with_GP", XS_B__GV_isGV_with_GP, file);
        newXS("B::GV::GP", XS_B__GV_GP, file);
        newXS("B::GV::STASH", XS_B__GV_STASH, file);
        newXS("B::GV::SV", XS_B__GV_SV, file);
        newXS("B::GV::IO", XS_B__GV_IO, file);
        newXS("B::GV::FORM", XS_B__GV_FORM, file);
        newXS("B::GV::AV", XS_B__GV_AV, file);
        newXS("B::GV::HV", XS_B__GV_HV, file);
        newXS("B::GV::EGV", XS_B__GV_EGV, file);
        newXS("B::GV::CV", XS_B__GV_CV, file);
        newXS("B::GV::CVGEN", XS_B__GV_CVGEN, file);
        newXS("B::GV::LINE", XS_B__GV_LINE, file);
        newXS("B::GV::FILE", XS_B__GV_FILE, file);
        newXS("B::GV::FILEGV", XS_B__GV_FILEGV, file);
        newXS("B::GV::GvREFCNT", XS_B__GV_GvREFCNT, file);
        newXS("B::GV::GvFLAGS", XS_B__GV_GvFLAGS, file);
        newXS("B::IO::LINES", XS_B__IO_LINES, file);
        newXS("B::IO::PAGE", XS_B__IO_PAGE, file);
        newXS("B::IO::PAGE_LEN", XS_B__IO_PAGE_LEN, file);
        newXS("B::IO::LINES_LEFT", XS_B__IO_LINES_LEFT, file);
        newXS("B::IO::TOP_NAME", XS_B__IO_TOP_NAME, file);
        newXS("B::IO::TOP_GV", XS_B__IO_TOP_GV, file);
        newXS("B::IO::FMT_NAME", XS_B__IO_FMT_NAME, file);
        newXS("B::IO::FMT_GV", XS_B__IO_FMT_GV, file);
        newXS("B::IO::BOTTOM_NAME", XS_B__IO_BOTTOM_NAME, file);
        newXS("B::IO::BOTTOM_GV", XS_B__IO_BOTTOM_GV, file);
#if XSubPPtmpAAAT
        newXS("B::IO::SUBPROCESS", XS_B__IO_SUBPROCESS, file);
#endif
        newXS("B::IO::IsSTD", XS_B__IO_IsSTD, file);
        newXS("B::IO::IoTYPE", XS_B__IO_IoTYPE, file);
        newXS("B::IO::IoFLAGS", XS_B__IO_IoFLAGS, file);
        newXS("B::AV::FILL", XS_B__AV_FILL, file);
        newXS("B::AV::MAX", XS_B__AV_MAX, file);
#if XSubPPtmpAAAU
        newXS("B::AV::OFF", XS_B__AV_OFF, file);
#endif
        newXS("B::AV::ARRAY", XS_B__AV_ARRAY, file);
        newXS("B::AV::ARRAYelt", XS_B__AV_ARRAYelt, file);
#if XSubPPtmpAAAV
        newXS("B::AV::AvFLAGS", XS_B__AV_AvFLAGS, file);
#endif
        newXS("B::FM::LINES", XS_B__FM_LINES, file);
        newXS("B::CV::CONST", XS_B__CV_CONST, file);
        newXS("B::CV::STASH", XS_B__CV_STASH, file);
        newXS("B::CV::START", XS_B__CV_START, file);
        newXS("B::CV::ROOT", XS_B__CV_ROOT, file);
        newXS("B::CV::GV", XS_B__CV_GV, file);
        newXS("B::CV::FILE", XS_B__CV_FILE, file);
        newXS("B::CV::DEPTH", XS_B__CV_DEPTH, file);
        newXS("B::CV::PADLIST", XS_B__CV_PADLIST, file);
        newXS("B::CV::OUTSIDE", XS_B__CV_OUTSIDE, file);
        newXS("B::CV::OUTSIDE_SEQ", XS_B__CV_OUTSIDE_SEQ, file);
        newXS("B::CV::XSUB", XS_B__CV_XSUB, file);
        newXS("B::CV::XSUBANY", XS_B__CV_XSUBANY, file);
        newXS("B::CV::CvFLAGS", XS_B__CV_CvFLAGS, file);
        newXS("B::CV::const_sv", XS_B__CV_const_sv, file);
        newXS("B::HV::FILL", XS_B__HV_FILL, file);
        newXS("B::HV::MAX", XS_B__HV_MAX, file);
        newXS("B::HV::KEYS", XS_B__HV_KEYS, file);
        newXS("B::HV::RITER", XS_B__HV_RITER, file);
        newXS("B::HV::NAME", XS_B__HV_NAME, file);
#if XSubPPtmpAAAW
        newXS("B::HV::PMROOT", XS_B__HV_PMROOT, file);
#endif
        newXS("B::HV::ARRAY", XS_B__HV_ARRAY, file);
        newXS("B::HE::VAL", XS_B__HE_VAL, file);
        newXS("B::HE::HASH", XS_B__HE_HASH, file);
        newXS("B::HE::SVKEY_force", XS_B__HE_SVKEY_force, file);
#if XSubPPtmpAAAX
        newXS("B::RHE::HASH", XS_B__RHE_HASH, file);
#endif

    /* Initialisation Section */

#line 597 "B.xs"
{
    HV *stash = gv_stashpvn("B", 1, GV_ADD);
    AV *export_ok = perl_get_av("B::EXPORT_OK", GV_ADD);
    MY_CXT_INIT;
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
    specialsv_list[4] = (SV *) pWARN_ALL;
    specialsv_list[5] = (SV *) pWARN_NONE;
    specialsv_list[6] = (SV *) pWARN_STD;
#if PERL_VERSION <= 8
#  define OPpPAD_STATE 0
#endif
#include "defsubs.h"
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#if XSubPPtmpAAAK
#endif
#if XSubPPtmpAAAL
#endif
#if XSubPPtmpAAAM
#endif
#if XSubPPtmpAAAN
#endif
#if XSubPPtmpAAAO
#endif
#if XSubPPtmpAAAP
#endif
#if XSubPPtmpAAAQ
#endif
#if XSubPPtmpAAAR
#endif
#if XSubPPtmpAAAS
#endif
#if XSubPPtmpAAAT
#endif
#if XSubPPtmpAAAU
#endif
#if XSubPPtmpAAAV
#endif
#if XSubPPtmpAAAW
#endif
#if XSubPPtmpAAAX
#endif
#line 7047 "B.c"

    /* End of Initialisation Section */

    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

