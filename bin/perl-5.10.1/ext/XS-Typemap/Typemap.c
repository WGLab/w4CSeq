/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of Typemap.xs. Do not edit this file, edit Typemap.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Typemap.xs"

/*
   XS code to test the typemap entries

   Copyright (C) 2001 Tim Jenness.
   All Rights Reserved

*/

#include "EXTERN.h"   /* std perl include */
#include "perl.h"     /* std perl include */
#include "XSUB.h"     /* XSUB include */

/* Prototypes for external functions */
FILE * xsfopen( const char * );
int xsfclose( FILE * );
int xsfprintf( FILE *, const char *);

/* Type definitions required for the XS typemaps */
typedef SV * SVREF; /* T_SVREF */
typedef int SysRet; /* T_SYSRET */
typedef int Int;    /* T_INT */
typedef int intRef; /* T_PTRREF */
typedef int intObj; /* T_PTROBJ */
typedef int intRefIv; /* T_REF_IV_PTR */
typedef int intArray; /* T_ARRAY */
typedef short shortOPQ;   /* T_OPAQUE */
typedef int intOpq;   /* T_OPAQUEPTR */

/* A structure to test T_OPAQUEPTR */
struct t_opaqueptr {
  int a;
  int b;
  double c;
};

typedef struct t_opaqueptr astruct;

/* Some static memory for the tests */
static I32 xst_anint;
static intRef xst_anintref;
static intObj xst_anintobj;
static intRefIv xst_anintrefiv;
static intOpq xst_anintopq;

/* Helper functions */

/* T_ARRAY - allocate some memory */
intArray * intArrayPtr( int nelem ) {
    intArray * array;
    Newx(array, nelem, intArray);
    return array;
}


#line 66 "Typemap.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 109 "Typemap.c"

XS(XS_XS__Typemap_T_SV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0);
	SV *	RETVAL;
#line 80 "Typemap.xs"
  /* create a new sv for return that is a copy of the input
     do not simply copy the pointer since the SV will be marked
     mortal by the INPUT typemap when it is pushed back onto the stack */
  RETVAL = sv_mortalcopy( sv );
  /* increment the refcount since the default INPUT typemap mortalizes
     by default and we don't want to decrement the ref count twice
     by mistake */
  SvREFCNT_inc(RETVAL);
#line 133 "Typemap.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_SVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SVREF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "svref");
    {
	SVREF	svref;
	SVREF	RETVAL;

	if (SvROK(ST(0)))
	    svref = (SV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"XS::Typemap::T_SVREF",
			"svref");
#line 101 "Typemap.xs"
  RETVAL = svref;
#line 163 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_AVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_AVREF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	AV *	av;
	AV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVAV)
	    av = (AV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not an array reference",
			"XS::Typemap::T_AVREF",
			"av");
#line 116 "Typemap.xs"
  RETVAL = av;
#line 193 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_HVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_HVREF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	HV *	hv;
	HV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    hv = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"XS::Typemap::T_HVREF",
			"hv");
#line 131 "Typemap.xs"
  RETVAL = hv;
#line 223 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_CVREF); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_CVREF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	CV *	cv;
	CV *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVCV)
	    cv = (CV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a code reference",
			"XS::Typemap::T_CVREF",
			"cv");
#line 147 "Typemap.xs"
  RETVAL = cv;
#line 253 "Typemap.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_SYSRET_pass); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SYSRET_pass)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SysRet	RETVAL;
#line 174 "Typemap.xs"
  RETVAL = 0;
#line 275 "Typemap.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_SYSRET_fail); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_SYSRET_fail)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SysRet	RETVAL;
#line 183 "Typemap.xs"
  RETVAL = -1;
#line 302 "Typemap.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_UV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_UV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "uv");
    {
	unsigned int	uv = (unsigned int)SvUV(ST(0));
	unsigned int	RETVAL;
	dXSTARG;
#line 197 "Typemap.xs"
  RETVAL = uv;
#line 331 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_IV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_IV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "iv");
    {
	long	iv = (long)SvIV(ST(0));
	long	RETVAL;
	dXSTARG;
#line 212 "Typemap.xs"
  RETVAL = iv;
#line 354 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_ENUM); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_ENUM)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	svtype	RETVAL;
	dXSTARG;
#line 239 "Typemap.xs"
  RETVAL = SVt_PVHV;
#line 376 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_BOOL); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_BOOL)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	bool	in = (bool)SvTRUE(ST(0));
	bool	RETVAL;
#line 254 "Typemap.xs"
  RETVAL = in;
#line 398 "Typemap.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_U_SHORT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_U_SHORT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	U16	in = (unsigned short)SvUV(ST(0));
	U16	RETVAL;
	dXSTARG;
#line 284 "Typemap.xs"
  RETVAL = in;
#line 422 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_U_LONG); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_U_LONG)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	U32	in = (unsigned long)SvUV(ST(0));
	U32	RETVAL;
	dXSTARG;
#line 309 "Typemap.xs"
  RETVAL = in;
#line 445 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_CHAR); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_CHAR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	char	in = (char)*SvPV_nolen(ST(0));
	char	RETVAL;
	dXSTARG;
#line 323 "Typemap.xs"
  RETVAL = in;
#line 468 "Typemap.c"
	XSprePUSH; PUSHp((char *)&RETVAL, 1);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_U_CHAR); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_U_CHAR)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	unsigned char	in = (unsigned char)SvUV(ST(0));
	unsigned char	RETVAL;
	dXSTARG;
#line 338 "Typemap.xs"
  RETVAL = in;
#line 491 "Typemap.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_FLOAT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_FLOAT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	float	in = (float)SvNV(ST(0));
	float	RETVAL;
	dXSTARG;
#line 354 "Typemap.xs"
  RETVAL = in;
#line 514 "Typemap.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_NV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_NV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	NV	in = (NV)SvNV(ST(0));
	NV	RETVAL;
	dXSTARG;
#line 370 "Typemap.xs"
  RETVAL = in;
#line 537 "Typemap.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_DOUBLE); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_DOUBLE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	double	in = (double)SvNV(ST(0));
	double	RETVAL;
	dXSTARG;
#line 385 "Typemap.xs"
  RETVAL = in;
#line 560 "Typemap.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_PV); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PV)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	char *	in = (char *)SvPV_nolen(ST(0));
	char *	RETVAL;
	dXSTARG;
#line 399 "Typemap.xs"
  RETVAL = in;
#line 583 "Typemap.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_PTR_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTR_OUT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	int	in = (int)SvIV(ST(0));
	void *	RETVAL;
	dXSTARG;
#line 417 "Typemap.xs"
  xst_anint = in;
  RETVAL = &xst_anint;
#line 607 "Typemap.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_PTR_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTR_IN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ptr");
    {
	void *	ptr = INT2PTR(void *,SvIV(ST(0)));
	int	RETVAL;
	dXSTARG;
#line 428 "Typemap.xs"
  RETVAL = *(int *)ptr;
#line 630 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_PTRREF_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTRREF_OUT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	intRef	in = (intRef)SvIV(ST(0));
	intRef *	RETVAL;
#line 451 "Typemap.xs"
  xst_anintref = in;
  RETVAL = &xst_anintref;
#line 653 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), Nullch, (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_PTRREF_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTRREF_IN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ptr");
    {
	intRef *	ptr;
	intRef	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ptr = INT2PTR(intRef *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"XS::Typemap::T_PTRREF_IN",
			"ptr");
#line 462 "Typemap.xs"
  RETVAL = *ptr;
#line 686 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_PTROBJ_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_PTROBJ_OUT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	intObj	in = (intObj)SvIV(ST(0));
	intObj *	RETVAL;
#line 489 "Typemap.xs"
  xst_anintobj = in;
  RETVAL = &xst_anintobj;
#line 709 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "intObjPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_intObjPtr_T_PTROBJ_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_intObjPtr_T_PTROBJ_IN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ptr");
    {
	intObj *	ptr;
	intObj	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "intObjPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ptr = INT2PTR(intObj *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"intObjPtr::T_PTROBJ_IN",
			"ptr", "intObjPtr");
#line 502 "Typemap.xs"
  RETVAL = *ptr;
#line 742 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_REF_IV_PTR_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_REF_IV_PTR_OUT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "in");
    {
	intRefIv	in = (intRefIv)SvIV(ST(0));
	intRefIv *	RETVAL;
#line 532 "Typemap.xs"
  xst_anintrefiv = in;
  RETVAL = &xst_anintrefiv;
#line 765 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "intRefIvPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_intRefIvPtr_T_REF_IV_PTR_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_intRefIvPtr_T_REF_IV_PTR_IN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ptr");
    {
	intRefIv *	ptr;
	intRefIv	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "intRefIvPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ptr = INT2PTR(intRefIv *, tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"intRefIvPtr::T_REF_IV_PTR_IN",
			"ptr", "intRefIvPtr");
#line 545 "Typemap.xs"
  RETVAL = *ptr;
#line 798 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_OPAQUEPTR_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_IN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "val");
    {
	intOpq	val = (intOpq)SvIV(ST(0));
	intOpq *	RETVAL;
	dXSTARG;
#line 588 "Typemap.xs"
  xst_anintopq = val;
  RETVAL = &xst_anintopq;
#line 822 "Typemap.c"
	XSprePUSH; PUSHp((char *)RETVAL, sizeof(*RETVAL));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_OPAQUEPTR_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_OUT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ptr");
    {
	intOpq *	ptr = (intOpq *)SvPV_nolen(ST(0));
	intOpq	RETVAL;
	dXSTARG;
#line 597 "Typemap.xs"
  RETVAL = *ptr;
#line 845 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_short); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_short)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "ptr");
    {
	shortOPQ *	ptr = (shortOPQ *)SvPV_nolen(ST(0));
	short	RETVAL;
	dXSTARG;
#line 605 "Typemap.xs"
  RETVAL = *ptr;
#line 868 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_OPAQUEPTR_IN_struct); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_IN_struct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "a, b, c");
    {
	int	a = (int)SvIV(ST(0));
	int	b = (int)SvIV(ST(1));
	double	c = (double)SvNV(ST(2));
#line 616 "Typemap.xs"
  struct t_opaqueptr test;
#line 891 "Typemap.c"
	astruct *	RETVAL;
	dXSTARG;
#line 618 "Typemap.xs"
  test.a = a;
  test.b = b;
  test.c = c;
  RETVAL = &test;
#line 899 "Typemap.c"
	XSprePUSH; PUSHp((char *)RETVAL, sizeof(*RETVAL));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_struct); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUEPTR_OUT_struct)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "test");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	astruct *	test = (astruct *)SvPV_nolen(ST(0));
#line 629 "Typemap.xs"
  XPUSHs(sv_2mortal(newSViv(test->a)));
  XPUSHs(sv_2mortal(newSViv(test->b)));
  XPUSHs(sv_2mortal(newSVnv(test->c)));
#line 924 "Typemap.c"
	PUTBACK;
	return;
    }
}


XS(XS_XS__Typemap_T_OPAQUE_IN); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUE_IN)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "val");
    {
	int	val = (int)SvIV(ST(0));
	shortOPQ	RETVAL;
	dXSTARG;
#line 657 "Typemap.xs"
  RETVAL = (shortOPQ)val;
#line 947 "Typemap.c"
	XSprePUSH; PUSHp((char *)&RETVAL, sizeof(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_OPAQUE_OUT); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUE_OUT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "val");
    {
	shortOPQ	val = *(shortOPQ *)SvPV_nolen(ST(0));
	IV	RETVAL;
	dXSTARG;
#line 665 "Typemap.xs"
  RETVAL = (IV)val;
#line 970 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_OPAQUE_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_OPAQUE_array)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "a, b, c");
    {
	int	a = (int)SvIV(ST(0));
	int	b = (int)SvIV(ST(1));
	int	c = (int)SvIV(ST(2));
#line 694 "Typemap.xs"
  int array[3];
#line 993 "Typemap.c"
	int *	RETVAL;
#line 696 "Typemap.xs"
  array[0] = a;
  array[1] = b;
  array[2] = c;
  RETVAL = array;
#line 1000 "Typemap.c"
	ST(0) = sv_newmortal();
	sv_setpvn(ST(0), (char *)RETVAL, 3 * sizeof(int));
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_ARRAY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "dummy, array, ...");
    {
	int	dummy = 0;
	intArray *	array;
#line 770 "Typemap.xs"
  U32 size_RETVAL;
#line 1023 "Typemap.c"
	intArray *	RETVAL;

	U32 ix_array = 1;
	array = intArrayPtr(items -= 1);
	while (items--) {
	    	array[ix_array - 1] = (int)SvIV(ST(ix_array));
	    ix_array++;
	}
        /* this is the number of elements in the array */
        ix_array -= 1;
#line 772 "Typemap.xs"
  dummy += 0; /* Fix -Wall */
  size_RETVAL = ix_array;
  RETVAL = array;
#line 1038 "Typemap.c"
        {
	    U32 ix_RETVAL;
	    EXTEND(SP,size_RETVAL);
	    for (ix_RETVAL = 0; ix_RETVAL < size_RETVAL; ix_RETVAL++) {
		ST(ix_RETVAL) = sv_newmortal();
		sv_setiv(ST(ix_RETVAL), (IV)RETVAL[ix_RETVAL]);
	    }
        }
#line 778 "Typemap.xs"
  Safefree(array);
  XSRETURN(size_RETVAL);
#line 1050 "Typemap.c"
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_STDIO_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_STDIO_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "file");
    {
	const char *	file = (const char *)SvPV_nolen(ST(0));
	FILE *	RETVAL;
#line 793 "Typemap.xs"
  RETVAL = xsfopen( file );
#line 1071 "Typemap.c"
	ST(0) = sv_newmortal();
	{
	    GV *gv = newGVgen("XS::Typemap");
	    PerlIO *fp = PerlIO_importFILE(RETVAL,0);
	    if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) )
		sv_setsv(ST(0), sv_bless(newRV((SV*)gv), gv_stashpv("XS::Typemap",1)));
	    else
		ST(0) = &PL_sv_undef;
	}
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_STDIO_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_STDIO_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "f");
    {
	PerlIO *	f = IoIFP(sv_2io(ST(0)));
#line 801 "Typemap.xs"
  FILE * stream;
#line 1100 "Typemap.c"
	SysRet	RETVAL;
#line 803 "Typemap.xs"
  /* Get the FILE* */
  stream = PerlIO_findFILE( f );  
  /* Release the FILE* from the PerlIO system so that we do
     not close the file twice */
  PerlIO_releaseFILE(f,stream);
  /* Must release the file before closing it */
  RETVAL = xsfclose( stream );
#line 1110 "Typemap.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}


XS(XS_XS__Typemap_T_STDIO_print); /* prototype to pass -Wmissing-prototypes */
XS(XS_XS__Typemap_T_STDIO_print)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "stream, string");
    {
	FILE *	stream = PerlIO_findFILE(IoIFP(sv_2io(ST(0))));
	const char *	string = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 818 "Typemap.xs"
  RETVAL = xsfprintf( stream, string );
#line 1140 "Typemap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_XS__Typemap); /* prototype to pass -Wmissing-prototypes */
XS(boot_XS__Typemap)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("XS::Typemap::T_SV", XS_XS__Typemap_T_SV, file);
        newXS("XS::Typemap::T_SVREF", XS_XS__Typemap_T_SVREF, file);
        newXS("XS::Typemap::T_AVREF", XS_XS__Typemap_T_AVREF, file);
        newXS("XS::Typemap::T_HVREF", XS_XS__Typemap_T_HVREF, file);
        newXS("XS::Typemap::T_CVREF", XS_XS__Typemap_T_CVREF, file);
        newXS("XS::Typemap::T_SYSRET_pass", XS_XS__Typemap_T_SYSRET_pass, file);
        newXS("XS::Typemap::T_SYSRET_fail", XS_XS__Typemap_T_SYSRET_fail, file);
        newXS("XS::Typemap::T_UV", XS_XS__Typemap_T_UV, file);
        newXS("XS::Typemap::T_IV", XS_XS__Typemap_T_IV, file);
        newXS("XS::Typemap::T_ENUM", XS_XS__Typemap_T_ENUM, file);
        newXS("XS::Typemap::T_BOOL", XS_XS__Typemap_T_BOOL, file);
        newXS("XS::Typemap::T_U_SHORT", XS_XS__Typemap_T_U_SHORT, file);
        newXS("XS::Typemap::T_U_LONG", XS_XS__Typemap_T_U_LONG, file);
        newXS("XS::Typemap::T_CHAR", XS_XS__Typemap_T_CHAR, file);
        newXS("XS::Typemap::T_U_CHAR", XS_XS__Typemap_T_U_CHAR, file);
        newXS("XS::Typemap::T_FLOAT", XS_XS__Typemap_T_FLOAT, file);
        newXS("XS::Typemap::T_NV", XS_XS__Typemap_T_NV, file);
        newXS("XS::Typemap::T_DOUBLE", XS_XS__Typemap_T_DOUBLE, file);
        newXS("XS::Typemap::T_PV", XS_XS__Typemap_T_PV, file);
        newXS("XS::Typemap::T_PTR_OUT", XS_XS__Typemap_T_PTR_OUT, file);
        newXS("XS::Typemap::T_PTR_IN", XS_XS__Typemap_T_PTR_IN, file);
        newXS("XS::Typemap::T_PTRREF_OUT", XS_XS__Typemap_T_PTRREF_OUT, file);
        newXS("XS::Typemap::T_PTRREF_IN", XS_XS__Typemap_T_PTRREF_IN, file);
        newXS("XS::Typemap::T_PTROBJ_OUT", XS_XS__Typemap_T_PTROBJ_OUT, file);
        newXS("intObjPtr::T_PTROBJ_IN", XS_intObjPtr_T_PTROBJ_IN, file);
        newXS("XS::Typemap::T_REF_IV_PTR_OUT", XS_XS__Typemap_T_REF_IV_PTR_OUT, file);
        newXS("intRefIvPtr::T_REF_IV_PTR_IN", XS_intRefIvPtr_T_REF_IV_PTR_IN, file);
        newXS("XS::Typemap::T_OPAQUEPTR_IN", XS_XS__Typemap_T_OPAQUEPTR_IN, file);
        newXS("XS::Typemap::T_OPAQUEPTR_OUT", XS_XS__Typemap_T_OPAQUEPTR_OUT, file);
        newXS("XS::Typemap::T_OPAQUEPTR_OUT_short", XS_XS__Typemap_T_OPAQUEPTR_OUT_short, file);
        newXS("XS::Typemap::T_OPAQUEPTR_IN_struct", XS_XS__Typemap_T_OPAQUEPTR_IN_struct, file);
        newXS("XS::Typemap::T_OPAQUEPTR_OUT_struct", XS_XS__Typemap_T_OPAQUEPTR_OUT_struct, file);
        newXS("XS::Typemap::T_OPAQUE_IN", XS_XS__Typemap_T_OPAQUE_IN, file);
        newXS("XS::Typemap::T_OPAQUE_OUT", XS_XS__Typemap_T_OPAQUE_OUT, file);
        newXS("XS::Typemap::T_OPAQUE_array", XS_XS__Typemap_T_OPAQUE_array, file);
        newXS("XS::Typemap::T_ARRAY", XS_XS__Typemap_T_ARRAY, file);
        newXS("XS::Typemap::T_STDIO_open", XS_XS__Typemap_T_STDIO_open, file);
        newXS("XS::Typemap::T_STDIO_close", XS_XS__Typemap_T_STDIO_close, file);
        newXS("XS::Typemap::T_STDIO_print", XS_XS__Typemap_T_STDIO_print, file);
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

